// SPDX-FileCopyrightText: 2024 SAP SE or an SAP affiliate company and Greenhouse contributors
// SPDX-License-Identifier: Apache-2.0

package v1alpha1

import (
	"slices"

	sourcev1 "github.com/fluxcd/source-controller/api/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	greenhousemetav1alpha1 "github.com/cloudoperators/greenhouse/api/meta/v1alpha1"
)

const (
	CatalogReadyReason    greenhousemetav1alpha1.ConditionReason = "CatalogReady"
	CatalogNotReadyReason greenhousemetav1alpha1.ConditionReason = "CatalogNotReady"
)

// CatalogSpec defines the desired state of Catalog.
type CatalogSpec struct {
	// Sources contains the list of Git Repository source to resolve PluginDefinitions / ClusterPluginDefinitions from
	Sources []CatalogSource `json:"sources"`
}

type CatalogSource struct {
	// Repository - the Git repository URL
	Repository string `json:"repository"`

	// Resources contains the list of path to PluginDefinition files
	// e.g. ["plugins/plugin-a.yaml", "plugins/plugin-b.yaml"]
	// glob patterns are supported, e.g. ["plugins/*.yaml", "more-plugins/**/plugindefinition.yaml"]
	Resources []string `json:"resources"`

	// Ref is the git reference (branch, tag, or SHA) to resolve PluginDefinitions from
	// precedence: SHA > Tag > Branch
	// if not specified, defaults to the branch "main"
	// +Optional
	Ref *GitRef `json:"ref,omitempty"`
	// SecretName is the name of v1.Secret containing credentials to access the Git repository
	// the secret must be in the same namespace as the Catalog resource
	/*
	  GitHub App Example:
	  -------------------
	  githubAppID: "<app-id>"
	  githubAppInstallationID: "<app-installation-id>"
	  githubAppPrivateKey: |
	    -----BEGIN RSA PRIVATE KEY-----
	    ...
	    -----END RSA PRIVATE KEY-----
	  githubAppBaseURL: "<github-enterprise-api-url>" #optional, required only for GitHub Enterprise Server users
	  ca.crt: | #optional, for GitHub Enterprise Server users
	    -----BEGIN CERTIFICATE-----
	    ...
	    -----END CERTIFICATE-----

	  GitHub Token Example:
	  -------------------
	  username: <BASE64>
	  password: <BASE64>
	  ca.crt: <BASE64> #optional, for GitHub Enterprise Server users
	*/
	// +Optional
	SecretName *string `json:"secretName,omitempty"`

	// Overrides are the PluginDefinition overrides to be applied
	// +Optional
	Overrides []CatalogOverrides `json:"overrides,omitempty"`
}

type CatalogOverrides struct {
	// Name is the name of the PluginDefinition to patch with an alias
	Name string `json:"name"`
	// Alias is the alias to apply to the PluginDefinition Name via Kustomize patches
	// For SourceType Helm, this field is passed to postRender Kustomize patch
	Alias string `json:"alias"`
	// Repository is the repository to override in the PluginDefinition .spec.helmChart.repository
	// +Optional
	Repository string `json:"repository,omitempty"`
}

type GitRef struct {
	Branch *string `json:"branch,omitempty"`
	Tag    *string `json:"tag,omitempty"`
	SHA    *string `json:"sha,omitempty"`
}

type SourceStatus struct {
	Kind    string                 `json:"kind"`
	Name    string                 `json:"name"`
	Ready   metav1.ConditionStatus `json:"ready,omitempty"`
	Message string                 `json:"message,omitempty"`
}

// CatalogStatus defines the observed state of Catalog.
type CatalogStatus struct {
	// StatusConditions contain the different conditions that constitute the status of the Catalog
	// +Optional
	greenhousemetav1alpha1.StatusConditions `json:"statusConditions,omitempty"`
	// Inventory contains list of internal artifacts generated by Catalog
	// +Optional
	Inventory map[string][]SourceStatus `json:"inventory,omitempty"`

	// LastReconciledAt contains the value when the reconcile was last triggered via annotation.
	// +Optional
	LastReconciledAt string `json:"lastReconciledAt,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
//+kubebuilder:printcolumn:name="Ready",type="string",JSONPath=`.status.statusConditions.conditions[?(@.type == "Ready")].status`
// +kubebuilder:resource:shortName=cat

// Catalog is the Schema for the catalogs API.
type Catalog struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   CatalogSpec   `json:"spec,omitempty"`
	Status CatalogStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CatalogList contains a list of Catalog.
type CatalogList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Catalog `json:"items"`
}

func (c *Catalog) SetInventory(hash, kind, name, msg string, ready metav1.ConditionStatus) {
	if c.Status.Inventory == nil {
		c.Status.Inventory = make(map[string][]SourceStatus)
	}
	if _, ok := c.Status.Inventory[hash]; !ok {
		c.Status.Inventory[hash] = make([]SourceStatus, 0, 4)
	}
	idx := slices.IndexFunc(c.Status.Inventory[hash], func(in SourceStatus) bool {
		return in.Kind == kind && in.Name == name
	})
	if idx == -1 {
		c.Status.Inventory[hash] = append(c.Status.Inventory[hash], SourceStatus{Kind: kind, Name: name, Message: msg, Ready: ready})
		return
	}
	c.Status.Inventory[hash][idx].Message = msg
	c.Status.Inventory[hash][idx].Ready = ready
}

func (s *CatalogSource) GetRefValue() (gitRef string) {
	if s.Ref == nil {
		gitRef = "main"
		return
	}
	switch {
	case s.Ref.SHA != nil:
		gitRef = *s.Ref.SHA
	case s.Ref.Tag != nil:
		gitRef = *s.Ref.Tag
	case s.Ref.Branch != nil:
		gitRef = *s.Ref.Branch
	default:
		gitRef = "main"
	}
	return
}

func (s *CatalogSource) GetGitRepositoryReference() *sourcev1.GitRepositoryRef {
	gitReference := &sourcev1.GitRepositoryRef{}
	if s.Ref != nil {
		// flux precedence 1
		if s.Ref.SHA != nil {
			gitReference.Commit = *s.Ref.SHA
		}
		// flux precedence 2
		if s.Ref.Tag != nil {
			gitReference.Tag = *s.Ref.Tag
		}
		// flux precedence 3
		if s.Ref.Branch != nil {
			gitReference.Branch = *s.Ref.Branch
		}
	}
	return gitReference
}

func (c *Catalog) GetConditions() greenhousemetav1alpha1.StatusConditions {
	return c.Status.StatusConditions
}

func (c *Catalog) SetCondition(condition greenhousemetav1alpha1.Condition) {
	c.Status.SetConditions(condition)
}

func (o *Catalog) UpdateLastReconciledAtStatus(value string) {
	o.Status.LastReconciledAt = value
}

// SetUnknownCondition - sets ready conditions to Unknown if not already set.
func (c *Catalog) SetUnknownCondition() {
	if cond := c.Status.GetConditionByType(greenhousemetav1alpha1.ReadyCondition); cond == nil {
		c.SetCondition(
			greenhousemetav1alpha1.UnknownCondition(greenhousemetav1alpha1.ReadyCondition, CatalogNotReadyReason, "Catalog reconciliation in progress"),
		)
	}
}

func (c *Catalog) SetFalseCondition(conditionType greenhousemetav1alpha1.ConditionType, reason greenhousemetav1alpha1.ConditionReason, message string) {
	c.SetCondition(greenhousemetav1alpha1.FalseCondition(conditionType, reason, message))
}

func (c *Catalog) SetTrueCondition(conditionType greenhousemetav1alpha1.ConditionType, reason greenhousemetav1alpha1.ConditionReason, message string) {
	c.SetCondition(greenhousemetav1alpha1.TrueCondition(conditionType, reason, message))
}

func init() {
	SchemeBuilder.Register(&Catalog{}, &CatalogList{})
}
