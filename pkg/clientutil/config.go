// Copyright 2024-2026 SAP SE or an SAP affiliate company and Greenhouse contributors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package clientutil

import (
	"fmt"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	clientcmdapi "k8s.io/client-go/tools/clientcmd/api"

	greenhouseapis "github.com/cloudoperators/greenhouse/pkg/apis"
)

func ValidateSecretForKubeConfig(secret *corev1.Secret) error {
	switch {
	// Secret is not of the right type
	case secret.Type != greenhouseapis.SecretTypeKubeConfig:
		return fmt.Errorf("secret %s/%s is not of type %s", secret.GetNamespace(), secret.GetName(), greenhouseapis.SecretTypeKubeConfig)
	// Try the kubeconfig generated by Greenhouse first.
	// Fallback to user-provided kubeconfig.
	case !IsSecretContainsKey(secret, greenhouseapis.GreenHouseKubeConfigKey) && !IsSecretContainsKey(secret, greenhouseapis.KubeConfigKey):
		return fmt.Errorf(
			"secret %s/%s does not contain a kubeconfig", secret.GetNamespace(), secret.GetName(),
		)
	}
	return nil
}

func NewClientConfigLoaderFromBytes(kubeConfig []byte) clientcmd.ClientConfigLoader {
	return &ClientConfigGetter{
		kubeConfigGetter: kubeConfigGetterFromBytes(kubeConfig),
	}
}

func NewClientConfigLoaderFromSecret(kubeConfig *corev1.Secret) clientcmd.ClientConfigLoader {
	return &ClientConfigGetter{
		kubeConfigGetter: kubeConfigGetterFromSecret(kubeConfig),
	}
}

// ClientConfigGetter implements the clientcmd.ClientConfigLoader interface.
type ClientConfigGetter struct {
	kubeConfigGetter clientcmd.KubeconfigGetter
}

func (g *ClientConfigGetter) Load() (*clientcmdapi.Config, error) {
	return g.kubeConfigGetter()
}
func (g *ClientConfigGetter) GetLoadingPrecedence() []string {
	return nil
}
func (g *ClientConfigGetter) GetStartingConfig() (*clientcmdapi.Config, error) {
	return g.kubeConfigGetter()
}
func (g *ClientConfigGetter) GetDefaultFilename() string {
	return ""
}
func (g *ClientConfigGetter) IsExplicitFile() bool {
	return false
}
func (g *ClientConfigGetter) GetExplicitFile() string {
	return ""
}
func (g *ClientConfigGetter) IsDefaultConfig(config *rest.Config) bool {
	return false
}

// KubeConfigGetterFromBytes implements clientcmd.KubeConfigGetter interface.
func kubeConfigGetterFromBytes(kubeConfig []byte) clientcmd.KubeconfigGetter {
	return func() (*clientcmdapi.Config, error) {
		cfg, err := clientcmd.NewClientConfigFromBytes(kubeConfig)
		if err != nil {
			return nil, err
		}
		apiCfg, err := cfg.RawConfig()
		if err != nil {
			return nil, err
		}
		return &apiCfg, nil
	}
}

// KubeConfigGetterFromSecret implements clientcmd.KubeConfigGetter interface.
func kubeConfigGetterFromSecret(secret *corev1.Secret) clientcmd.KubeconfigGetter {
	return func() (*clientcmdapi.Config, error) {
		if err := ValidateSecretForKubeConfig(secret); err != nil {
			return nil, err
		}
		switch {
		// Try the kubeconfig generated by Greenhouse first.
		case IsSecretContainsKey(secret, greenhouseapis.GreenHouseKubeConfigKey):
			return kubeConfigGetterFromBytes(secret.Data[greenhouseapis.GreenHouseKubeConfigKey])()
		// Fallback to user-provided kubeconfig.
		case IsSecretContainsKey(secret, greenhouseapis.KubeConfigKey):
			return kubeConfigGetterFromBytes(secret.Data[greenhouseapis.KubeConfigKey])()
		// Error if the secret does not contain a kubeconfig.
		default:
			return nil, fmt.Errorf(
				"secret %s/%s does not contain a kubeconfig", secret.GetNamespace(), secret.GetName(),
			)
		}
	}
}
